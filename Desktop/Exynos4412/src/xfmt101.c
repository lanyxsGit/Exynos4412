#include <stdio.h>
#include <string.h>
#include "../include/serial.h"
#include "../include/xfmt101.h"



/*******XFMT101_Init()************/
int XFMT101_Init(char *XFMT101_dev)
{
	int xfd = OpenDev(XFMT101_dev);  /*初始化XFMT101串口*/
	if (xfd < 0)
	{
		printf("Open %s Device file failure\n", XFMT101_dev);
		return -1;
	}
	set_speed(xfd, 115200);
	if (set_Parity(xfd, 8, 1, 'N') == FALSE)
	{
		printf("XFMT101 Set Parity Error\n");
		close(xfd);
		return -1;
	}
	return xfd;
}



/*******计算校验位****************/
unsigned char cal_check_bit(unsigned char *Command)
{
	unsigned char i = 2;
	unsigned char len = Command[2] + 4;
	int sum = 0;
	for (i = 2; i < len; i++)
	{
		sum += Command[i];
	}
	return sum %= 256;
}

/*******温湿度语音合成*************/
void TemAndHum_compose(int xfd, unsigned char tem, unsigned char hum)
{
	unsigned char digit_hex[10] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39};
	unsigned char Wakeup[] = {0x19, 0xB2, 0x05, 0x00, 0x12, 0x02, 0x00, 0x00, 0x00, 0x19};
	write(xfd, Wakeup, sizeof(Wakeup));
	sleep(1);
	/*tem 10~25  hum:30%~80%*/
	if (tem >= 25 && hum >= 30 && hum <= 80)   //温度过高
	{
		unsigned char CmdTemHum[49] = {0x19, 0xB2, 0x2C, 0x00, 0x13, 0x00, 0xB5, 0xB1, 0xC7, 0xB0, 0xCE, 0xC2, 0xB6, 0xC8, 0x32, 0x36, 0xB6, 0xC8, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0x35, 0x36, 0xA3, 0xAC, 0xCE, 0xC2, 0xB6, 0xC8, 0xB9, 0xFD, 0xB8, 0xDF, 0xA3, 0xAC, 0xC7, 0xEB, 0xB4, 0xF2, 0xBF, 0xAA, 0xBF, 0xD5, 0xB5, 0xF7, 0x36};
		CmdTemHum[14] = digit_hex[tem / 10];
		CmdTemHum[15] = digit_hex[tem % 10];
		CmdTemHum[24] = digit_hex[hum / 10];
		CmdTemHum[25] = digit_hex[hum % 10];
		CmdTemHum[48] = cal_check_bit(CmdTemHum);
		write(xfd, CmdTemHum, sizeof(CmdTemHum));
		//sleep(7);
	}
	else if (tem <= 10 && hum >= 30 && hum <= 80) //温度过低
	{
		unsigned char CmdTemHum[49] = {0x19, 0xB2, 0x2C, 0x00, 0x13, 0x00, 0xB5, 0xB1, 0xC7, 0xB0, 0xCE, 0xC2, 0xB6, 0xC8, 0x32, 0x36, 0xB6, 0xC8, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0x35, 0x36, 0xA3, 0xAC, 0xCE, 0xC2, 0xB6, 0xC8, 0xB9, 0xFD, 0xB5, 0xCD, 0xA3, 0xAC, 0xC7, 0xEB, 0xB4, 0xF2, 0xBF, 0xAA, 0xC5, 0xAF, 0xB7, 0xE7, 0x36};
		CmdTemHum[14] = digit_hex[tem / 10];
		CmdTemHum[15] = digit_hex[tem % 10];
		CmdTemHum[24] = digit_hex[hum / 10];
		CmdTemHum[25] = digit_hex[hum % 10];
		CmdTemHum[48] = cal_check_bit(CmdTemHum);
		write(xfd, CmdTemHum, sizeof(CmdTemHum));
		//sleep(7);
	}
	else if (hum >= 80 && tem >= 10 && tem <= 25) //湿度过高
	{
		unsigned char CmdTemHum[49] = {0x19, 0xB2, 0x2C, 0x00, 0x13, 0x00, 0xB5, 0xB1, 0xC7, 0xB0, 0xCE, 0xC2, 0xB6, 0xC8, 0x32, 0x36, 0xB6, 0xC8, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0x35, 0x36, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0xB9, 0xFD, 0xB8, 0xDF, 0xA3, 0xAC, 0xC7, 0xEB, 0xB4, 0xF2, 0xBF, 0xAA, 0xB4, 0xB0, 0xBB, 0xA7, 0x36};
		CmdTemHum[14] = digit_hex[tem / 10];
		CmdTemHum[15] = digit_hex[tem % 10];
		CmdTemHum[24] = digit_hex[hum / 10];
		CmdTemHum[25] = digit_hex[hum % 10];
		CmdTemHum[48] = cal_check_bit(CmdTemHum);
		write(xfd, CmdTemHum, sizeof(CmdTemHum));
		//sleep(7);
	}
	else if (hum <= 30 && tem >= 10 && tem <= 25) //湿度过低
	{
		unsigned char CmdTemHum[49] = {0x19, 0xB2, 0x2C, 0x00, 0x13, 0x00, 0xB5, 0xB1, 0xC7, 0xB0, 0xCE, 0xC2, 0xB6, 0xC8, 0x32, 0x36, 0xB6, 0xC8, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0x35, 0x36, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0xB9, 0xFD, 0xB5, 0xCD, 0xA3, 0xAC, 0xC7, 0xEB, 0xB9, 0xD8, 0xB1, 0xD5, 0xB4, 0xB0, 0xBB, 0xA7, 0x36};
		CmdTemHum[14] = digit_hex[tem / 10];
		CmdTemHum[15] = digit_hex[tem % 10];
		CmdTemHum[24] = digit_hex[hum / 10];
		CmdTemHum[25] = digit_hex[hum % 10];
		CmdTemHum[48] = cal_check_bit(CmdTemHum);
		write(xfd, CmdTemHum, sizeof(CmdTemHum));
		//sleep(7);
	}
	else if (tem >= 25 && hum >= 80) //温湿度同时过高
	{
		unsigned char CmdTemHum[53] = {0x19, 0xB2, 0x30, 0x00, 0x13, 0x00, 0xB5, 0xB1, 0xC7, 0xB0, 0xCE, 0xC2, 0xB6, 0xC8, 0x32, 0x36, 0xB6, 0xC8, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0x35, 0x36, 0xA3, 0xAC, 0xCA, 0xD2, 0xC4, 0xDA, 0xB3, 0xB1, 0xCA, 0xAA, 0xA3, 0xAC, 0xC7, 0xEB, 0xB4, 0xF2, 0xBF, 0xAA, 0xB4, 0xB0, 0xBB, 0xA7, 0xCD, 0xA8, 0xB7, 0xE7, 0x00};
		CmdTemHum[14] = digit_hex[tem / 10];
		CmdTemHum[15] = digit_hex[tem % 10];
		CmdTemHum[24] = digit_hex[hum / 10];
		CmdTemHum[25] = digit_hex[hum % 10];
		CmdTemHum[52] = cal_check_bit(CmdTemHum);
		write(xfd, CmdTemHum, sizeof(CmdTemHum));
		//sleep(7);
	}
	else if (tem <= 10 && hum <= 30)  //温湿度同时过低
	{
		unsigned char CmdTemHum[49] = {0x19, 0xB2, 0x2C, 0x00, 0x13, 0x00, 0xB5, 0xB1, 0xC7, 0xB0, 0xCE, 0xC2, 0xB6, 0xC8, 0x32, 0x36, 0xB6, 0xC8, 0xA3, 0xAC, 0xCA, 0xAA, 0xB6, 0xC8, 0x35, 0x36, 0xA3, 0xAC, 0xCA, 0xD2, 0xC4, 0xDA, 0xB8, 0xC9, 0xD4, 0xEF, 0xA3, 0xAC, 0xC7, 0xEB, 0xBC, 0xB0, 0xCA, 0xB1, 0xBD, 0xB5, 0xCA, 0xAA, 0x00};
		CmdTemHum[14] = digit_hex[tem / 10];
		CmdTemHum[15] = digit_hex[tem % 10];
		CmdTemHum[24] = digit_hex[hum / 10];
		CmdTemHum[25] = digit_hex[hum % 10];
		CmdTemHum[48] = cal_check_bit(CmdTemHum);
		write(xfd, CmdTemHum, sizeof(CmdTemHum));
		//sleep(7);
	}
}


/******烟雾警报语音合成*************/
void SmokeAlarm_Voicecps(int xfd, int smokeDensity)
{
	unsigned char digit_hex[10] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39};
	unsigned char Wakeup[] = {0x19, 0xB2, 0x05, 0x00, 0x12, 0x02, 0x00, 0x00, 0x00, 0x19};
	write(xfd, Wakeup, sizeof(Wakeup));
	sleep(1);
	unsigned char CmdSmoke[28] = {0x19, 0xB2, 0x17, 0x00, 0x13, 0x00, 0xBE, 0xAF, 0xB1, 0xA8, 0xBE, 0xAF, 0xB1, 0xA8, 0xA3, 0xAC, 0xD1, 0xCC, 0xCE, 0xED, 0xC5, 0xA8, 0xB6, 0xC8, 0x32, 0x30, 0x30, 0x00};
	printf("%d\n", smokeDensity);
	CmdSmoke[24] = digit_hex[smokeDensity / 100];
	CmdSmoke[25] = digit_hex[smokeDensity / 10 % 10];
	CmdSmoke[26] = digit_hex[smokeDensity % 10];
	CmdSmoke[27] = cal_check_bit(CmdSmoke);
	printf("24 is %d,25 is %d ,26 is %d\n", CmdSmoke[24], CmdSmoke[25], CmdSmoke[26]);
	write(xfd, CmdSmoke, sizeof(CmdSmoke));
	sleep(3);
}

/******防盗警报语音合成*************/
void BurglarAlarm_Voicecps(int xfd)
{
	unsigned char Wakeup[] = {0x19, 0xB2, 0x05, 0x00, 0x12, 0x02, 0x00, 0x00, 0x00, 0x19};
	write(xfd, Wakeup, sizeof(Wakeup));
	sleep(1);
	unsigned char CmdBurglar[24] = {0x19, 0xB2, 0x13, 0x00, 0x13, 0x00, 0xBE, 0xAF, 0xB1, 0xA8, 0xBE, 0xAF, 0xB1, 0xA8, 0x2C, 0xB7, 0xC7, 0xB7, 0xA8, 0xB4, 0xB3, 0xC8, 0xEB, 0x00};
	CmdBurglar[23] = cal_check_bit(CmdBurglar);
	write(xfd, CmdBurglar, sizeof(CmdBurglar));
	sleep(2);
}


/*****开门提醒语音合成************/
void OpenDoor_Voicecps(int xfd)
{
	unsigned char Wakeup[] = {0x19, 0xB2, 0x05, 0x00, 0x12, 0x02, 0x00, 0x00, 0x00, 0x19};
	write(xfd, Wakeup, sizeof(Wakeup));
	sleep(1);
	unsigned char CmdOpenDoor[15] = {0x19, 0xB2, 0x0A, 0x00, 0x13, 0x00, 0xC3, 0xC5, 0xD2, 0xD1, 0xB4, 0xF2, 0xBF, 0xAA, 0x00};
	CmdOpenDoor[14] = cal_check_bit(CmdOpenDoor);
	write(xfd, CmdOpenDoor, sizeof(CmdOpenDoor));
	sleep(1);
}

/*****离家模式提醒语音合成************/
void Leave_Voicecps(int xfd)
{
	unsigned char Wakeup[] = {0x19, 0xB2, 0x05, 0x00, 0x12, 0x02, 0x00, 0x00, 0x00, 0x19};
	write(xfd, Wakeup, sizeof(Wakeup));
	sleep(1);
	unsigned char CmdLeave[34] = {0x19, 0xB2, 0x1D, 0x00, 0x13, 0x00, 0xC0, 0xEB, 0xBC, 0xD2, 0xC4, 0xA3, 0xCA, 0xBD, 0xBF, 0xAA, 0xC6, 0xF4, 0xB3, 0xC9, 0xB9, 0xA6, 0x2C, 0xBD, 0xAB, 0xB3, 0xD6, 0xD0, 0xF8, 0xBC, 0xE0, 0xBF, 0xD8, 0x00};
	CmdLeave[33] = cal_check_bit(CmdLeave);
	write(xfd, CmdLeave, sizeof(CmdLeave));
	sleep(3);
}


/*****回家模式提醒语音合成************/
void GoHome_Voicecps(int xfd)
{
	unsigned char Wakeup[] = {0x19, 0xB2, 0x05, 0x00, 0x12, 0x02, 0x00, 0x00, 0x00, 0x19};
	write(xfd, Wakeup, sizeof(Wakeup));
	sleep(1);
	unsigned char CmdGoHome[15] = {0x19, 0xB2, 0x0A, 0x00, 0x13, 0x00, 0xBB, 0xB6, 0xD3, 0xAD, 0xBB, 0xD8, 0xBC, 0xD2, 0x00};
	CmdGoHome[14] = cal_check_bit(CmdGoHome);
	write(xfd, CmdGoHome, sizeof(CmdGoHome));
	sleep(2);
}


